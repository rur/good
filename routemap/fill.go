package routemap

import (
	"fmt"
	"path/filepath"
	"regexp"
	"strings"

	toml "github.com/pelletier/go-toml"
	"github.com/rur/good/generate"
)

var (
	// view '_ref' must be strictly lower, kebab-case string
	refRegex = regexp.MustCompile("^[a-z][a-z0-9]*(-[a-z][a-z0-9]*)*$")

	metaKeys = map[string]bool{
		"_ref":      true,
		"_default":  true,
		"_doc":      true,
		"_path":     true,
		"_template": true,
		"_handler":  true,
		"_method":   true,
		"_fragment": true,
		"_partial":  true,
		"_includes": true,
	}
)

type treeStackData struct {
	tree      *toml.Tree
	blockPath []string
}

func popTreeStack(stack *[]treeStackData) treeStackData {
	sLen := len(*stack)
	d := (*stack)[sLen-1]
	*stack = (*stack)[:sLen-1]
	return d
}

// FillMissingTemplatesAndHandlers will scan the routemap TOML tree for missing template or handler
// entries, generate a
func FillMissingTemplatesAndHandlers(doc *toml.Tree, templatePath string) (templates []generate.HTMLTemplate, handlers []generate.Handler, err error) {
	stack := []treeStackData{
		{tree: doc},
	}

	// emitting entries using a pre-order traversal will ensure that all view variable are declared
	// before they are used to create sub views
	for len(stack) > 0 {
		sData := popTreeStack(&stack)
		tree := sData.tree
		// process level of the tree
		pos := tree.Position()
		var blocks []string
		for _, key := range tree.Keys() {
			if _, ok := metaKeys[key]; ok {
				continue
			} else if refRegex.MatchString(key) {
				blocks = append(blocks, key)
			} else {
				err = fmt.Errorf(":%d:%d: invalid key/blockname '%s'", pos.Line, pos.Col, key)
				return
			}
		}
		ref, ok := tree.Get("_ref").(string)
		if !ok {
			err = fmt.Errorf(":%d:%d: _ref key is missing or invalid", pos.Line, pos.Col)
			return
		} else if !refRegex.MatchString(ref) {
			err = fmt.Errorf(":%d:%d: _ref must all lower, kebab-case string, got '%s'", pos.Line, pos.Col, ref)
			return
		}
		if !tree.Has("_template") || tree.Get("_template") == "" {
			tmpl := generate.HTMLTemplate{
				Path: filepath.Join(append([]string{templatePath}, append(sData.blockPath, ref+".html.tmpl")...)...),
			}
			for _, block := range blocks {
				tmpl.Blocks = append(tmpl.Blocks, generate.HandleBlock{
					FieldName: kebabToCamel("-" + block),
					Name:      block,
				})
			}
			templates = append(templates, tmpl)
			tree.SetPathWithComment([]string{"_template"}, "generated by good routes", false, tmpl.Path)
		}
		if !tree.Has("_handler") || tree.Get("_handler") == "" {
			hlr := generate.Handler{
				Ref:        ref,
				Identifier: fmt.Sprintf("%sHandler", kebabToCamel(ref)),
			}
			if len(sData.blockPath) > 0 {
				hlr.Block = fmt.Sprintf("[[%s]]", strings.Join(sData.blockPath, "."))
			}
			if method, ok := tree.Get("_method").(string); ok {
				hlr.Method = method
			}
			for _, block := range blocks {
				hlr.Blocks = append(hlr.Blocks, generate.HandleBlock{
					FieldName: kebabToCamel("-" + block),
					Name:      block,
				})
			}
			handlers = append(handlers, hlr)
			tree.SetPathWithComment([]string{"_handler"}, "generated by good routes", false, hlr.Identifier)
		}

		for _, block := range blocks {
			subTrees, ok := tree.GetArray(block).([]*toml.Tree)
			if !ok {
				err = fmt.Errorf(":%d:%d: expecting array of records, got '%v'", pos.Line, pos.Col, tree.Get(block))
				return
			}
			subPath := append(sData.blockPath, block)
			for i := range subTrees {
				stack = append(stack, treeStackData{
					tree:      subTrees[i],
					blockPath: subPath,
				})
			}
		}
	}
	return
}
